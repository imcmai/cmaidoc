## 背景
#### 随着CPU，内存，I/O设备迭代，三者之间速度具有巨大差异，为了平衡三者速度差异，利用cpu的高性能
    - cpu增加了缓存，均衡与内存的速度差异
    - 操作系统增加了进程，线程，以达到分时复用cpu，均衡cpu与I/O设备的速度差异
    - 编译程序优化指令执行次序，使得缓存能更好被利用
所以，并发编程bug的源头，都是因为这些而产生
### 问题
##### 可见性
单核cpu所有线程都在一个cpu执行，所有线程写的都是同一个cpu缓存，所以这时是可以保持可见性的，但是在多核时代，不同线程有可能在不同的cpu缓存进行写操作，就会出现可见性问题，因为并不是直接从内存中读取数据，而是先写进cpu缓存，然后刷新内存值。
##### 原子性
为了更好的利用cpu，出现了进程，线程，操作系统调度任务分配给进程时间片，进程又包含无数个线程，进程也会调度线程，产生线程切换，任务切换就会导致原子性问题，比如 count++，在最终执行的cpu指令会分为三条
- 把变量从内存读到cpu寄存器
- 寄存器执行+1
- 结果写入内存(可能写入的是cpu缓存，不一定是内存)
所以会有可能在指令1或者指令2切换线程，导致出现count结果并不如自己想的那样
