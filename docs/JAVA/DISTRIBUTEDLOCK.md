- #### 锁的概念:
	- 线程的通信方式有两种，同步和可见性
	- 同步的本质是通过锁来实现，可见性只在特定情况下才能保证线程安全，比如volitile，对jvm优化过后的指令进行重排序，强制要求线程刷新主存，但是 如果当前值由该变量以前的值相关 比如执行非原子操作的++，那这时候就不安全了
	- 比如java中大量用到的synchronized 锁，同时满足同步和可见性
	这是在单机系统中，但是在分布式系统中，多个相同服务就不能达到同步了
***
- #### 分布式锁的实现
    - 其实这个东西说起来也很简单，就是微服务的时代下应运而生的东西，实现方式主要为借助中间件 比如redis, memcached ,zookeeper等，有了这些中间件，分布式服务都会通过中间件去拿取和销毁锁，这样来完成同步

- #### memcached的实现:
    - client客户端用的是memcached-java-client
    - 会去memcached中插入一个k v ，k如果存在返回失败，否则返回true，比如应用于回绝重复请求，请求id可以作为key，设置time的过期时间是为了避免客户端宕机后造成死锁，另外memcached宕机的话，数据是不会恢复的，没有持久化功能，需要注意，集群一定程度上可以避免这个问题
```java
memCachedClient.add(key, value, time);
```
- #### Redis的实现
    - 借助到setnx关键字同样也是，存入kv，设置成功则表示加锁成功，但是jedis早期不支持add函数中添加过期时间，所以就有了expire这个方法， 但是两步操作造成不是原子性的，后面更新后可以直接用add方法，也可以执行Lua脚本

> 后续会讲讲zk 和 redlock(redis集群下的锁)以及分布式锁的应用和优化

